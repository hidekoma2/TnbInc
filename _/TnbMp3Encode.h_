#pragma once
/**
 *@file
 *@ingroup FILE
 * MP3 エンコード関係のヘッダ
 *
 *	@todo 未完成。
 *
 *	@see TnbDef.h 利用条件、および下記の無保証規定
 */



#include "TnbStr.h"
#include "TnbDynamicFunc.h"



//TNB Library
namespace TNB
{



#ifndef _TnbDOXYGEN	//Document作成用シンボル
	namespace GOGO
	{
		//[午後のこ〜だ]の提供ヘッダ
		#include "other/GOGO.h"
	};
	using namespace TNB::GOGO;
#endif



/**@ingroup FILE
 * MP3 エンコード処理クラス
 *
 *	@note	「午後のこ〜だ」の dllを使用しています。
 *
 *	@todo 未完成。
 *
 *	@see http://www.marinecat.net/free/windows/mct_free.htm
 *
 *	@par必要ファイル:
 *			TnbMp3Encode.h
 *
 *	@date 06/12/08 新規作成
 */
class CMp3Encoder : CCopyImpossible
{
public:

	struct IListener
	{
		virtual ~IListener(void) {}

		/**
		 * [通知] １フレーム終了
		 *	@param iNow 終了フレーム数
		 *	@param iMax 全フレーム数
		 *	@retval ture 継続。
		 *	@retval false 中断要求。
		 */
		virtual bool OnEncodedOneFrame(int iNow,int iMax) = 0;
	};

private:

	HINSTANCE		m_hModule;
	MERET (*m_pMe_initializeWork)(void);
	MERET (*m_pMe_setConfigure)(MPARAM mode, UPARAM dwPara1, UPARAM dwPara2);
	MERET (*m_pMe_getConfigure)(MPARAM mode, void* para1);
	MERET (*m_pMe_detectConfigure)(void);
	MERET (*m_pMe_processFrame)(void);
	MERET (*m_pMe_closeCoder)(void);
	MERET (*m_pMe_endCoder)(void);
	MERET (*m_pMe_getVersion)(unsigned long* vercode, char* verstring);
	MERET (*m_pMe_getUnitStates)(unsigned long* unit);

	// DLLの読み込み(最初の1回目のみ)とワークエリアの初期化を行います。
	bool m_Init(void)
	{
		if ( m_hModule != NULL )
		{
			return true;
		}
		HINSTANCE h = ::LoadLibraryA("gogo.dll");
		if ( h == NULL )
		{
			return false;
		}
		// エクスポート関数の取得
		bool r = true;
		r &= GetFuncAddress(m_pMe_initializeWork,	h, "MPGE_initializeWork");
		r &= GetFuncAddress(m_pMe_setConfigure,		h, "MPGE_setConfigure");
		r &= GetFuncAddress(m_pMe_getConfigure,		h, "MPGE_getConfigure");
		r &= GetFuncAddress(m_pMe_detectConfigure,	h, "MPGE_detectConfigure");
		r &= GetFuncAddress(m_pMe_processFrame,		h, "MPGE_processFrame");
		r &= GetFuncAddress(m_pMe_closeCoder,		h, "MPGE_closeCoder");
		r &= GetFuncAddress(m_pMe_endCoder,			h, "MPGE_endCoder");
		r &= GetFuncAddress(m_pMe_getVersion,		h, "MPGE_getVersion");
		r &= GetFuncAddress(m_pMe_getUnitStates,	h, "MPGE_getUnitStates");
		if ( r )
		{
			m_hModule = h;
		}
		else 
		{
			::FreeLibrary(h);
		}
		return r;
	}

public:

	/**
	 * コンストラクタ
	 *	@note DLLのローディングも行なっちゃいます。
	 */
	CMp3Encoder(void) : m_hModule(NULL)
	{
		m_Init();
	}

	/// デストラクタ
	~CMp3Encoder(void)
	{
		if ( m_hModule != NULL )
		{
			::FreeLibrary(m_hModule);
			m_hModule = NULL;
		}
	}

	/**
	 * [設定] エンコード時の条件設定
	 *	@param mode 項目名を指定します。
	 *	@param para1 エンコード条件に対応したパラメータを設定します。
	 *	@param para2 エンコード条件に対応したパラメータを設定します。
	 *	@retval true 正常終了。
	 *	@retval false パラメーターの範囲、パラメーターの項目が正しくない。　 
	 */
	template<typename T1, typename T2>
	bool SetConfigure(MPARAM mode, T1 para1, T2 para2)
	{
		MERET r = m_pMe_setConfigure(mode, (UPARAM)para1, (UPARAM)para2);
		return r == ME_NOERR;
	}

	/**
	 * [取得] ユニット＆CPU種取得.
	 *	@note	エンコードに使用可能なユニット、およびCPUの種類を
	 *			特定するビットの組み合わせを取得します。返り値は、
	 *			ビットパターンの論理和を取ったものになります。
	 *	@retval ０ エラー
	 *	@retval ０以外 ビットパターンの論理和を取ったもの。
	 */
	DWORD GetUnitStates(void)
	{
		UPARAM nUnitCode;
		MERET r = m_pMe_getUnitStates(&nUnitCode);
		return (r != ME_NOERR) ? 0 : nUnitCode;
	}

	/**
	 * [取得] DLLバージョン取得
	 *	@note	バージョンを示す文字列を取得します。(例: "ver 1.25 1999/09/25" )
	 *	@retval Empty状態 エラー。
	 *	@retval Empty以外状態 バージョン文字列。
	 */
	CStr GetVersion(void)
	{
		unsigned long nVerCode;
		char buf[260];
		if ( m_pMe_getVersion(&nVerCode, buf) != ME_NOERR )
		{
			return CStr();
		}
		return CStr(buf);
	}

	/**
	 * [取得] DLLバージョン取得
	 *	@note	バージョンコードを取得します。8ビット目が小数点になります。 (例: 0x220 = Ver2.20)
	 *	@retval ０ エラー。
	 *	@retval ０以外 バージョンコード。
	 */
	DWORD GetVersionCode(void)
	{
		unsigned long nVerCode;
		char buf[260];
		if ( m_pMe_getVersion(&nVerCode, buf) != ME_NOERR )
		{
			return 0;
		}
		return nVerCode;
	}

	/**
	 * [設定] WAVEファイル指定
	 *	@note	エンコードするWAVファイルを指定します。
	 *	@retval true 成功。
	 *	@retval false 失敗。
	 */
	bool SetSource(LPCTSTR lpszFile)
	{
		return SetConfigure(MC_INPUTFILE, MC_INPDEV_FILE, lpszFile);
	}

	/**
	 * [取得] フレーム数取得
	 *	@note	フレーム数を取得します。 SetSource() でWAVEファイルを指定している必要があります。
	 *	@retval ０ エラー。
	 *	@retval ０以外 フレーム数。
	 */
	DWORD GetSourceFrameCount(void)
	{
		UPARAM nFrames;
		if ( m_pMe_getConfigure(MG_COUNT_FRAME, &nFrames) != ME_NOERR )
		{
			nFrames = 0;
		}
		return nFrames;
	}




};



}; // TNB